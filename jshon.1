.\" man 7 groff_mdoc  Best resource ever
.Dd July 20, 2011
.Dt JSHON \&1 "Jshon Manual"
.Os " "
.Sh NAME
.Nm jshon
.Nd JSON parser for the shell
.Sh SYNOPSIS
.Nm jshon
-[t|l|k|u|p|a] -s value -[e|i] index -m index,value
.Sh DESCRIPTION
.Nm
parses, reads and creates JSON.  It is designed to be as usable as possible from within the shell and replaces fragile adhoc parsers made from grep/sed/awk.
.Pp
.Nm
loads json text from stdin, performs actions, then dumps to stdout.  Some of the options output json, others output plain text summaries.  Because Bash has very poor nested datastructures,
.Nm
does not return the JSON as a native bash object.  Instead,
.Nm
retains a history of edits in a stack, and you manipulate the JSON element on the top of the stack.  This increases memory use compared to other parsers, but is not too bad.  Actions should be chained sequentially to reduce calls.
.
.Sh ACTIONS
Each action takes the form of a short option.  Some require arguments.  All examples use this json sample:
.Pp
\&  {"a":1,"b":[true,false,null,"none"],"c":{"d":4,"e":5}}
.br
\&  jshon [actions] < sample.json
.Pp
Most common uses will only need several
.Nm \-e 
actions and one
.Nm \-a
in the middle of them.
.Pp
.Bl -tag -width ".." -compact
.It Cm -t
(type) returns string, object, list, number, bool, null
.Pp
\&  jshon -t -> object
.Pp
.It Cm -l
(length) returns an integer.  Only works on string, object, list.
.Pp
\&  jshon -l -> 3
.Pp
.It Cm -k
(keys) returns a newline separated list of keys.  Only works on object.
.Pp
\&  jshon -k -> a b c
.Pp
.It Cm -e index
(extract) returns json value at "index".  Only works on object, list.
.Pp
\&  jshon -e c -> {"d":4,"e":5}
.Pp
.It Cm -a
(across) maps the remaining actions across the selected element.  Only works on objects and lists.  Multiple -a calls can be nested, though the need is rare in practice.
.Pp
\&  jshon -e b -a -t -> bool bool null string
.Pp
.It Cm -s value
(string) returns a json encoded string.  Ignores stdin.
.Pp
\&  jshon -s "back\[rs]slash" -> "back\[rs]\[rs]slash"
.Pp
.It Cm -u
(unstring) returns a decoded string.  Only works on string.
.Pp
\&  jshon -e b -e 3 -u -> none
.Pp
.It Cm -p
(pop) pops the last manipulation from the stack, rewinding the history.  Useful for extracting multiple values from one object.
.Pp
\& jshon -e c -e d -u -p -e e -u -> 4 5
.Pp
.It Cm -m index,value
(modify) edits an element in a list or a dict.  Value must be escaped.  If value is remove, delete the index.  If value is true/false/null, insert the primitive type.  Quoting strings is optional, except for the ambiguous case of remove/true/false/null.  Lists support several magic indexes.  Negative numbers wrap around the back, and append will add a new element after the last.
.Pp
\&  jshon -m a,first -> {"a":"first", ...}
.Pp
.It Cm -i index
(insert) is complicated.  It is the reverse of extract.  Extract saves a copy of the json on a stack.  Insert pops json from the stack, and inserts that bit of json into the new top of the stack.  Use extract to dive into the json tree, modify to change something, and insert to push the changes back up the tree.
.Pp
\&  jshon -e a -i a -> the orginal json
.br
\&  jshon -e b -m 2,remove -m 2,remove -m append,1.2 -i b -> {"a":1, "b":[true,false,1.2], "c":{"d":4,"e":5}}
.Pp
.Sh AUTHORS
.An -nosplit
.Pp
.Nm
was written by
.An Kyle Keen Aq keenerd@gmail.com 
with patches from
.An Dave Reisner Aq d@falconindy.com ,
and
.An AndrewF .
.Sh BUGS
Numerous!  There are no stack over/underflow checks.  Forward slashes are not escaped.  Object indexes with commas are broken.  On any error it exits without saying why.  Documentation is very brief.

