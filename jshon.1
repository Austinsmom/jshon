.\" man 7 groff_mdoc  Best resource ever
.Dd November 4, 2011
.Dt JSHON \&1 "Jshon Manual"
.Os " "
.Sh NAME
.Nm jshon
.Nd JSON parser for the shell
.Sh SYNOPSIS
.Nm jshon
-[P|S|Q|t|l|k|u|p|a] -[s|n] value -[e|i|d] index
.Sh DESCRIPTION
.Nm
parses, reads and creates JSON.  It is designed to be as usable as possible from within the shell and replaces fragile adhoc parsers made from grep/sed/awk as well as heavyweight parsers made from perl/python.
.Pp
.Nm
loads json text from stdin, performs actions, then displays the last action on stdout.  Some of the options output json, others output plain text summaries.  Because Bash has very poor nested datastructures,
.Nm
does not return the JSON as a native object as a typical library would.  Instead,
.Nm
retains a history of edits in a stack, and you manipulate the topmost JSON element.  This increases memory use compared to other parsers, but only in pathological cases.
.
.Sh ACTIONS
Each action takes the form of a short option.  Some require arguments.  While many instances of 
.Nm
can be piped through each other, actions should be chained sequentially to reduce calls.  All examples use this json sample:
.Pp
\&  {"a":1,"b":[true,false,null,"none"],"c":{"d":4,"e":5}}
.br
\&  jshon [actions] < sample.json
.Pp
Most common read-only uses will only need several
.Nm \-e 
actions and one
.Nm \-a
in the middle of them.
.Pp
.Bl -tag -width ".." -compact
.It Cm -t
(type) returns string, object, list, number, bool, null
.Pp
\&  jshon -t -> object
.Pp
.It Cm -l
(length) returns an integer.  Only works on string, object, list.
.Pp
\&  jshon -l -> 3
.Pp
.It Cm -k
(keys) returns a newline separated list of keys.  Only works on object.
.Pp
\&  jshon -k -> a b c
.Pp
.It Cm -e index
(extract) returns json value at "index".  Only works on object, list.
.Pp
\&  jshon -e c -> {"d":4,"e":5}
.Pp
.It Cm -a
(across) maps the remaining actions across the selected element.  Only works on objects and lists.  Multiple -a calls can be nested, though the need is rare in practice.
.Pp
\&  jshon -e b -a -t -> bool bool null string
.Pp
.It Cm -s value
(string) returns a json encoded string.  Can also be (-i)nserted to an existing structure.
.Pp
\&  jshon -s "back\[rs]slash" -> "back\[rs]\[rs]slash"
.Pp
.It Cm -n value
(nonstring/number) returns a json encoded simple element.  Can also be (-i)nserted to an existing structure.  Valid values are 'true', 'false', 'none', integers and floats.
.Pp
.It Cm -u
(unstring) returns a decoded string.  Only works on simple types: string, int, real, boolean, null.
.Pp
\&  jshon -e b -e 3 -u -> none
.Pp
.It Cm -p
(pop) pops the last manipulation from the stack, rewinding the history.  Useful for extracting multiple values from one object.
.Pp
\& jshon -e c -e d -u -p -e e -u -> 4 5
.Pp
.It Cm -d index
(delete) removes an item in an array or object.  Negative array indexes will wrap around.
.Pp
\&  json -d b -> {"a":1,"c":{"d":4,"e":5}}
.Pp
.It Cm -i index
(insert) is complicated.  It is the reverse of extract.  Extract puts a json sub-element on the stack.  Insert removes a sub-element from the stack, and inserts that bit of json into the larger array/object underneath.  Use extract to dive into the json tree, delete to remove something, (non)string to add something, and insert to push the changes back up the tree.
.Pp
Arrays are handled in a special manner.  Passing integers will insert a value without overwriting.  Negative integers are acceptable, as is the string 'append'.  To overwrite a value in an array: delete the index,
.Nm \-n/s
the new value, and then insert at the index.
.Pp
\&  jshon -e a -i a -> the orginal json
.br
\&  jshon -s one -i a -> {"a":"one", ...}
.
.Pp
.Sh NON-MANIPULATION
There are several meta-options that do not directly edit json.  Call these at most once per invocation.
.Pp
.Bl -tag -width ".." -compact
.It Cm -P
(jsonp) strips a jsonp callback before continuing normally.
.Pp
.It Cm -S
(sort) returns json sorted by key, instead of the original ordering.
.Pp
.It Cm -Q
(quiet) disables error reporting on stderr, so you don't have to sprinkle "2> /dev/null" throughout your script.
.Pp
.Sh OTHER TOOLS
.Nm
always outputs one field per line.  Many unix tools expect multiple tab separated fields per line.  Pipe the output through 'paste' to fix this.  However, paste can not handle empty lines so pad those with a placeholder.  Here is an example:
.Pp
\&  jshon ... | sed 's/^$/-/' | paste -d '\\t\\t\\n'
.Pp
This replaces blanks with '-' and merges every three lines into one.
.Pp
.Sh AUTHORS
.An -nosplit
.Pp
.Nm
was written by
.An Kyle Keen Aq keenerd@gmail.com 
with patches from
.An Dave Reisner Aq d@falconindy.com ,
and
.An AndrewF .
.Sh BUGS
Numerous!  Forward slashes are not escaped.  Object indexes with commas are broken.  Documentation is brief.

